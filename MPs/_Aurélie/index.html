<!DOCTYPE HTML>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Calcul matriciel</title>
    <link rel="stylesheet" href="../css/stylesheet.css">
		<!-- import of webgl utilities -->
    <script src="../sharedJs/jquery-3.1.0.min.js"></script>
    <script src="../sharedJs/commonFunctions.js"></script>
    <script src="../sharedJs/gl-matrix-min.js"></script>
    <script src="../sharedJs/webglTools.js"></script>
		<script src="debug/webgl-debug.js"></script>
		<!-- import application scripts -->
    <script src="./js/matrix.js"></script>

    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
  			attribute vec4 aColor;
  			uniform mat4 uMVMatrix;
  			uniform mat4 uPMatrix;
  			varying vec4 vColor;
  			void main(void) {
  				vColor = aColor;
  				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  			}
    </script>
    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
				varying vec4 vColor;
				void main(void) {
				  gl_FragColor = vColor;
				}
    </script>
    <!--WebGL logique-->
    <script>
      //From: ch10ex1b
      var vertexBuffer = null;
      var indexBuffer = null;
      var textCoordsBuffer = null;
      var texColorTab = new Array();
      var indices = [];
      var vertices = [];
      var textCoords =[];
      var mvMatrix = mat4.create();
      var pMatrix = mat4.create();
      var textureSize = 1024;
      var currentTextureIndx;
			var rttFramebuffer = new Array();
		  var rttTexture = new Array();
      //From: ch10ex1b
      function initShaderParameters(prg){
        prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
        glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
        prg.textureCoordsAttribute  = glContext.getAttribLocation(prg, "aTextureCoord");
        glContext.enableVertexAttribArray(prg.textureCoordsAttribute);
        prg.pMatrixUniform          = glContext.getUniformLocation(prg, 'uPMatrix');
        prg.mvMatrixUniform         = glContext.getUniformLocation(prg, 'uMVMatrix');
        prg.modeUniform 		    = glContext.getUniformLocation(prg, "uMode");
        prg.uColorTexture 			= glContext.getUniformLocation(prg, "uColorTexture");
      }

      function initTextureFramebuffer(index) {
		        rttFramebuffer[index] = glContext.createFramebuffer();
		        glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[index]);
		        rttFramebuffer[index].width = textureSize;
		        rttFramebuffer[index].height = textureSize;
		        rttTexture[index] = glContext.createTexture();
		        glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[index]);
		        glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
				    glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
		        glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, rttFramebuffer[index].width,
		        rttFramebuffer[index].height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);
		        var renderbuffer = glContext.createRenderbuffer();
		        glContext.bindRenderbuffer(glContext.RENDERBUFFER, renderbuffer);
		        glContext.renderbufferStorage(glContext.RENDERBUFFER, glContext.DEPTH_COMPONENT16,
		        rttFramebuffer[index].width, rttFramebuffer[index].height);
		        glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0,
		        glContext.TEXTURE_2D, rttTexture[index], 0);
		        glContext.framebufferRenderbuffer(glContext.FRAMEBUFFER, glContext.DEPTH_ATTACHMENT,
		        glContext.RENDERBUFFER, renderbuffer);
		        glContext.bindTexture(glContext.TEXTURE_2D, null);
		        glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
		        glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
		    }
        function nMatrixFct(){
				  var nMatrix = mat4.create();
			    mat4.copy(nMatrix, mvMatrix);
			    mat4.invert(nMatrix, nMatrix);
			    mat4.transpose(nMatrix, nMatrix);
			    glContext.uniformMatrix4fv(prg.nMatrixUniform, false, nMatrix);
			}
      function identityMatrices() {
				mat4.identity(pMatrix);
				mat4.identity(mvMatrix);
				glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
				glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
				nMatrixFct();
			}

      //From : http://www.vizitsolutions.com/portfolio/webgl/gpgpu/implementation.html
    /*  function getStandardGeomatry(){
        return new Float32Array([-1.0, 1.0, 0.0, 0.0, 1.0, //upper left
                                  -1.0, -1.0, 0.0, 0.0, 0.0,//lower left
                                  1.0, 1.0, 0.0, 1.0, 1.0,//upper right
                                  1.0, -1.0, 0.0, 1.0, 0.0]);//lower right
      }*/

      function initWebGL(){
        glContext = GLTools_getGLContext('webgl-canvas');
        console.log("glContext "+glContext);
      }
    </script>
</head>
<body onload="initWebGL()">
  <h2>Entrer un fichier JSON contenant une matrice</h2>
  <input type="file" id="fileJson" name="files[]" accept=".json"/>
  <h3>Voici les deux matrices entrées</h3>
  <h4>Matrice A</h4>
  <table id="matrixATable">
  </table>
  <h4>Matrice B</h4>
  <table id="matrixBTable">
  </table>
  <br/>
  <h2>Résultat</h2>
  <table id="resultTable">
  </table>
  <canvas id="webgl-canvas" width="128" height="128" style="display:none">
  </canvas>
  <script>
  document.getElementById("fileJson").addEventListener("change",changeFileJson,false);
    //Récupération du fichier.
    function changeFileJson(evt){
      var file = evt.target.files[0];
      var fileJson = evt.target;
      var reader = new FileReader();
      reader.onload = function(){
        var text = reader.result;
        var parseText = JSON.parse(text);
        createMatrix(parseText);
      };
      reader.readAsText(fileJson.files[0]);
      //console.log("Fichier lu");
    }
    //Create matrix with the JSON file given
    function createMatrix(textJson){
      if(textJson == undefined || textJson.n == undefined || textJson.A == undefined || textJson.B == undefined){
        alert("Le fichier contenant la matrice comporte une erreur");
      }
      else{
        dimension = textJson.n;
        matrixA = new Matrix(dimension);
        matrixB = new Matrix(dimension);
        //Remplissage des matrices
        var size = Math.pow(dimension,2);
        var rowA = 0, rowB =0, colA = 0, colB=0;
        for(var i=0; i<size; i++){
          matrixA.put(rowA, colA++, textJson.A[i]);
          matrixB.put(rowB, colB++, textJson.B[i]);
          if((i+1)%dimension == 0){
            colA = 0;
            colB=0;
            rowA++;
            rowB++;
          }
        }
        console.log("Matrices construites");
        matrixA.display('matrixATable');
        console.log("matrixB");
        matrixB.display('matrixBTable');
        console.log("Matrices affichées");
      }
    }
    //Clear the table
    function clearTable(tableID){
      var table = document.getElementById(tableID);
      var row = table.rows.lenght;
      while(row--){
        table.deleteRow(row);
      }
    }

  </script>
</body>
</html>

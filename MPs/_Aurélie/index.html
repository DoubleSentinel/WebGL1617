<!DOCTYPE HTML>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Calcul matriciel</title>
    <link rel="stylesheet" href="../css/stylesheet.css">
		<!-- import of webgl utilities -->
    <script src="../sharedJs/jquery-3.1.0.min.js"></script>
    <script src="../sharedJs/commonFunctions.js"></script>
    <script src="../sharedJs/gl-matrix-min.js"></script>
    <script src="js/webglTools.js"></script>
		<script src="debug/webgl-debug.js"></script>
		<!-- import application scripts -->
    <script src="./js/matrix.js"></script>

    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      varying vec2 vTextureCoord;
      void main(void) {
        vTextureCoord = aTextureCoord;
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
      }
    </script>
    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
        uniform sampler2D uColorTexture;
        varying vec2 vTextureCoord;
        uniform int uMode;
				void main(void) {
          if (gl_FrontFacing){//indique si la primitive est front ou back facing
					vec2 mapCoord = vec2(vTextureCoord.s, vTextureCoord.t);
					vec4 texelColor = texture2D(uColorTexture, mapCoord);
					gl_FragColor = texelColor.rgba;
				}else{
					gl_FragColor = vec4(1.0,1.0,1.0,1.0);//Si quelque chose ne va pas
				  }
				}
    </script>
    <!--WebGL logique-->
    <script>
    //Texture shit from the book
    var texColorTab = new Array(); //stocke les textures
    var textCoords = [];

    var textureSize = 128;

    var vertexBuffer = null;
    var indexBuffer = null;
    var colorBuffer = null;
    var indices = [];
    var vertices = [];
    //var colors = [];
    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();

    function initShaderParameters(prg){
      prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
      glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
      //prg.colorAttribute = glContext.getAttribLocation(prg, "aColor");
      prg.textureCoordsAttribute  = glContext.getAttribLocation(prg, "aTextureCoord");
      glContext.enableVertexAttribArray(prg.textureCoordsAttribute);

      prg.pMatrixUniform          = glContext.getUniformLocation(prg, 'uPMatrix');
      prg.mvMatrixUniform         = glContext.getUniformLocation(prg, 'uMVMatrix');
      prg.uColorTexture 			= glContext.getUniformLocation(prg, "uColorTexture");
    }

    function initBuffers(){
      vertices = [ -1.0, -1.0, 0.0,
                   1.0, -1.0, 0.0,
                  -1.0,  1.0, 0.0,
                  1.0,  1.0, 0.0 ];
      indices = [ 0, 1, 2, 3 ];
      textCoords = [  0.0, 0.0,
                      1.0, 0.0,
                      0.0, 1.0,
                      1.0, 1.0 ];

      vertexBuffer = getVertexBufferWithVertices(vertices);
      indexBuffer = getIndexBufferWithIndices(indices);
      textCoordsBuffer = getArrayBufferWithArray(textCoords);
    }
    /*
      //Paramètres qui déterminent où on va faire le rendu
      var TEXTURE_RENDERING_MODE = 1;
      var SCREEN_RENDERING_MODE = 0;
      var renderPasses = 0;
      var rttFramebuffer = new Array();
      var rttTexture = new Array();*/
      //var rttFramebuffer = new Array();
      var rttTexture = new Array();
      var pixels = new Float32Array(4);//Pour pouvoir prendre les float de la texture.
      var texture;// = createBaseTexture(textureSize, texColorTab);

      function initTextureFramebuffer(texture) {
      	var fb = glContext.createFramebuffer();
        glContext.bindFramebuffer(glContext.FRAMEBUFFER, fb);
        fb.width = textureSize;
        fb.height = textureSize;
        //rttTexture[index] = glContext.createTexture();
        glContext.bindTexture(glContext.TEXTURE_2D, texture);
        glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
				glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
        glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, fb.width, fb.height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);
        var renderbuffer = glContext.createRenderbuffer();
        glContext.bindRenderbuffer(glContext.RENDERBUFFER, renderbuffer);
        glContext.renderbufferStorage(glContext.RENDERBUFFER, glContext.DEPTH_COMPONENT16, fb.width, fb.height);
        glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0, glContext.TEXTURE_2D, texture, 0);
        glContext.framebufferRenderbuffer(glContext.FRAMEBUFFER, glContext.DEPTH_ATTACHMENT, glContext.RENDERBUFFER, renderbuffer);

        //console.log(textureSize);
        for(i=0; i<textureSize;i++){
          for(j=0; j<textureSize; j++){
            glContext.readPixels(0, 0, i, j, glContext.RGBA, glContext.FLOAT, pixels);//On lit les pixels
            //console.log(pixels);//Ne donne que des 0
          }
        }

        glContext.bindTexture(glContext.TEXTURE_2D, null);
        glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
        glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);//Unbind texture
      }

    /*  var renderPasses = 0;

      function renderInTexture(index){
			  glContext.viewport(0, 0, rttFramebuffer[index].width, rttFramebuffer[index].height);
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				glContext.activeTexture(glContext.TEXTURE0);
				if (renderPasses < 6){
					glContext.bindTexture(glContext.TEXTURE_2D, texColorTab[0]);
					glContext.uniform1i(prg.modeUniform, SCREEN_RENDERING_MODE);
				}else {
					glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[index == 0 ? 1 : 0]);
					glContext.uniform1i(prg.modeUniform, TEXTURE_RENDERING_MODE);
				}
				renderPasses++;
				mat4.identity(pMatrix);
				glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
				mat4.identity(mvMatrix);
				glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
				glContext.vertexAttribPointer(prg.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
		  }*/

      function generateTextureWith2Darray(data, newTexture){
				glContext.bindTexture(glContext.TEXTURE_2D, newTexture);
				glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, glContext.RGBA, glContext.UNSIGNED_BYTE, data);//Censé prendre le canvas et le passer en texture
				glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
				glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
      }

      function createBaseTexture(textureSize, texturen){//Dessiner sur la canvas et le passer en texture Donc c'est là qu'il faudra venir avec les matrices
        var c = document.createElement("canvas");
        //var c = document.getElementById("webgl-canvas");//Dans ce cas, le getContext est null, c'est dû au fait que le DOM n'est pas encore chargé quand
        //j'exècute cette ligne. Je n'ai pas résolus le problème vu que ce n'est pas si important.
        c.width = textureSize;
        c.height = textureSize;
         var ctx = c.getContext("2d", {preserveDrawingBuffer: true});
         console.log(ctx);
         var red = 1;//C'est les couleures qui sont importantes
         var green = 0;
         var blue = 0;
         ctx.fillStyle = "rgb(" + red + "," + green + "," + blue + ")";
         ctx.fillRect(0,0,textureSize,textureSize);//On s'en fout où est le rectangle

         var anz = texturen.length;
         texturen[anz] = glContext.createTexture();
         generateTextureWith2Darray(c, texturen[anz]);
         //console.log(texturen[anz]);
         return texturen[anz];
      }


      function drawScene(){//est appelée dans renderLoop() dans les webglTools
        glContext.clearColor(0.0,0.0,0.0,1.0);
        glContext.enable(glContext.DEPTH_TEST);
        glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
        glContext.viewport(0,0,c_width,c_height);
        mat4.identity(pMatrix);
        mat4.identity(mvMatrix);
        glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
        glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

      //  glContext.bindBuffer(glContext.ARRAY_BUFFER, normalBuffer);
      //  glContext.vertexAttribPointer(prg.vertexNormalAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
        glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
        glContext.vertexAttribPointer(prg.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);

        glContext.activeTexture(glContext.TEXTURE0);
        glContext.bindTexture(glContext.TEXTURE_2D, null);//ici on doit passer le nom de la texture créée, qu'on veut dessiner dans la scène, donc celle du résultat plutôt.
        //Ou plutôt balancer les deux textures pour faire les calculs dans le fragment sharder ?
        glContext.uniform1i(prg.uColorTexture, 0);//Lien pour transmettre la texture au fragment shader
      }

      function initWebGL(){
        glContext = getGLContext('webgl-canvas');
        console.log("glContext "+glContext);
        var float_texture = glContext.getExtension('OES_texture_float');//active l'extension
        initProgram();
        console.log("initProgram");
        //prg = glContext.createProgram();
        initBuffers();
        console.log("initBuffers");
        //A voir si cette fonction est utile
        texture = createBaseTexture(textureSize, texColorTab);
        console.log("createBaseTexture "+texture);
        initTextureFramebuffer(texture);
        console.log("initTextureFramebuffer");
        //initTextureFramebuffer(1);
        renderLoop();
      }
    </script>
</head>
<body onload="initWebGL()">
  <h2>Entrer un fichier JSON contenant une matrice</h2>
  <input type="file" id="fileJson" name="files[]" accept=".json"/>
  <h3>Voici les deux matrices entrées</h3>
  <h4>Matrice A</h4>
  <table id="matrixATable">
  </table>
  <h4>Matrice B</h4>
  <table id="matrixBTable">
  </table>
  <br/>
  <h2>Résultat</h2>
  <table id="resultTable">
  </table>
  <p>webgl-canvas</p>
  <canvas id="webgl-canvas" width="128" height="128">
    HTML5 is not supported
  </canvas>
  <script>
  document.getElementById("fileJson").addEventListener("change",changeFileJson,false);
    //Récupération du fichier.
    function changeFileJson(evt){
      var file = evt.target.files[0];
      var fileJson = evt.target;
      var reader = new FileReader();
      reader.onload = function(){
        var text = reader.result;
        var parseText = JSON.parse(text);
        createMatrix(parseText);
      };
      reader.readAsText(fileJson.files[0]);
      //console.log("Fichier lu");
    }
    //Create matrix with the JSON file given
    function createMatrix(textJson){
      if(textJson == undefined || textJson.n == undefined || textJson.A == undefined || textJson.B == undefined){
        alert("Le fichier contenant la matrice comporte une erreur");
      }
      else{
        dimension = textJson.n;
        matrixA = new Matrix(dimension);
        matrixB = new Matrix(dimension);
        //Remplissage des matrices
        var size = Math.pow(dimension,2);
        var rowA = 0, rowB =0, colA = 0, colB=0;
        for(var i=0; i<size; i++){
          matrixA.put(rowA, colA++, textJson.A[i]);
          matrixB.put(rowB, colB++, textJson.B[i]);
          if((i+1)%dimension == 0){
            colA = 0;
            colB=0;
            rowA++;
            rowB++;
          }
        }
        console.log("Matrices construites");
      //  matrixA.display('matrixATable');
        //console.log("matrixB");
        //matrixB.display('matrixBTable');
        //console.log("Matrices affichées");
      }
    }
    //Clear the table
    function clearTable(tableID){
      var table = document.getElementById(tableID);
      var row = table.rows.lenght;
      while(row--){
        table.deleteRow(row);
      }
    }

  </script>
</body>
</html>

<!DOCTYPE HTML>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Calcul matriciel</title>
    <link rel="stylesheet" href="../css/stylesheet.css">
		<!-- import of webgl utilities -->
    <script src="../sharedJs/jquery-3.1.0.min.js"></script>
    <script src="../sharedJs/commonFunctions.js"></script>
    <script src="../sharedJs/gl-matrix-min.js"></script>
    <script src="js/webglTools.js"></script>
		<script src="debug/webgl-debug.js"></script>
		<!-- import application scripts -->
    <script src="./js/matrix.js"></script>

    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      varying vec2 vTextureCoord;
      void main(void) {
        vTextureCoord = aTextureCoord;
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
      }
    </script>
    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
      /*  uniform sampler2D uColorTexture;
        varying vec2 vTextureCoord;
				void main(void) {
          if (gl_FrontFacing){//indique si la primitive est front ou back facing
					vec2 mapCoord = vec2(vTextureCoord.s, vTextureCoord.t);
					vec4 texelColor = texture2D(uColorTexture, mapCoord);
          //Avoir un deuxième sampler et faire l'addition ici
					gl_FragColor = texelColor.rgba;
				}else{
					gl_FragColor = vec4(1.0,1.0,1.0,1.0);//Si quelque chose ne va pas
				  }
				}*/
        varying vec2 vTextureCoord;
        uniform sampler2D uColorTexture;
        void main(void) {
            vec4 color = texture2D(uColorTexture, vTextureCoord);
            gl_FragColor = color;
        }
    </script>
    <!--WebGL logique-->
    <script>
    //Texture from the book
    var texColorTab = new Array(); //stocke les textures
    var textCoords = [];
    var textureA;

    var textureSize = 128;

    var vertexBuffer = null;
    var indexBuffer = null;
    var colorBuffer = null;
    var indices = [];
    var vertices = [];
    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();

    function initShaderParameters(prg){
      prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
      glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
      //prg.colorAttribute = glContext.getAttribLocation(prg, "aColor");
      prg.textureCoordsAttribute  = glContext.getAttribLocation(prg, "aTextureCoord");
      glContext.enableVertexAttribArray(prg.textureCoordsAttribute);

      prg.pMatrixUniform          = glContext.getUniformLocation(prg, 'uPMatrix');
      prg.mvMatrixUniform         = glContext.getUniformLocation(prg, 'uMVMatrix');
      prg.uColorTexture 			= glContext.getUniformLocation(prg, "uColorTexture");
    }

    function initBuffers(){
    /*  vertices = [ 1.0, 1.0, 0.1,
                   1.0, -1.0, 0.1,
                  -1.0,  1.0, 0.1,
                  -1.0,  -1.0, 0.1 ];*/
      vertices.push(1.0, 1.0, 0.1);
      vertices.push(1.0, -1.0, 0.1);
      vertices.push(-1.0,  1.0, 0.1);
      vertices.push(-1.0,  -1.0, 0.1);

      indices.push(0, 1, 2, 3);
      //indices = [ 0, 1, 2, 3 ];
      textCoords = [  0.0, 0.0,
                      0.0, 1.0,
                      1.0, 0.0,
                      1.0, 1.0 ];

      vertexBuffer = getVertexBufferWithVertices(vertices);
      indexBuffer = getIndexBufferWithIndices(indices);
      textCoordsBuffer = getArrayBufferWithArray(textCoords);
    }

//Pris de la fonction createImageFromTexture de cyril
      function readFromTexture(gl){
        var canvas = document.getElementById("canvas2");
        var context = canvas.getContext('2d');

        var height = canvas.height;
        var width = canvas.width;

        var framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureA, 0);

        //readFromTexture
        var pixels = new Uint8Array(width*height*4);//Pour pouvoir prendre les float de la texture.
        //Ne marche finalement pas avec des float, je suis obligée de les prendre en byte. Possibilité d'avoir UNSIGNED_SHORT. Ne semble pas marcher par rapport
        //au framebuffer. Donc ce sera avec des bytes.
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        //console.log(pixels);

        gl.deleteFramebuffer(framebuffer);

        var imageData = context.createImageData(width, height);
        imageData.data.set(pixels);
        context.putImageData(imageData,0,0);
      }

    /*  function initTextureFramebuffer() {
      	var fb = glContext.createFramebuffer();
        glContext.bindFramebuffer(glContext.FRAMEBUFFER, fb);
        fb.width = textureSize;
        fb.height = textureSize;
        rttTexture[0] = glContext.createTexture();//A voir
        glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[0]);
        glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
				glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
        glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, fb.width, fb.height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);
        var renderbuffer = glContext.createRenderbuffer();
        glContext.bindRenderbuffer(glContext.RENDERBUFFER, renderbuffer);
        glContext.renderbufferStorage(glContext.RENDERBUFFER, glContext.DEPTH_COMPONENT16, fb.width, fb.height);
        glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0, glContext.TEXTURE_2D, rttTexture[0], 0);
        glContext.framebufferRenderbuffer(glContext.FRAMEBUFFER, glContext.DEPTH_ATTACHMENT, glContext.RENDERBUFFER, renderbuffer);

        glContext.bindTexture(glContext.TEXTURE_2D, null);
        glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
        glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);//Unbind texture
      }*/

      function createBaseTexture(){//Dessiner sur la canvas et le passer en texture Donc c'est là qu'il faudra venir avec les matrices
          textureA = glContext.createTexture();
           var c = document.createElement("canvas");
           c.width = 128;
           c.height = 128;
           var ctx = c.getContext("2d");
           ctx.fillStyle="#FF0000";
           ctx.fillRect(0,0,c.width, c.height);
           glContext.bindTexture(glContext.TEXTURE_2D, textureA);
           glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, glContext.RGBA, glContext.UNSIGNED_BYTE, c);
           glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
           glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
           glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
           glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
      }


      function drawScene(){//est appelée dans renderLoop() dans les webglTools
        //glContext.clearColor(0.0,0.0,0.0,1.0);
        glContext.enable(glContext.DEPTH_TEST);
        glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
        glContext.viewport(0,0,c_width,c_height);
        mat4.identity(pMatrix);
        mat4.identity(mvMatrix);
        glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
        glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

        glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

        glContext.activeTexture(glContext.TEXTURE0);
        glContext.bindTexture(glContext.TEXTURE_2D, textureA);//ici on doit passer le nom de la texture créée, qu'on veut dessiner dans la scène, donc celle du résultat plutôt.

        //Ou plutôt balancer les deux textures pour faire les calculs dans le fragment sharder ?
        glContext.uniform1i(prg.uColorTexture, 0);//Lien pour transmettre la texture au fragment shade


        glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
        glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);

        glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
        glContext.vertexAttribPointer(prg.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);


        glContext.drawElements(glContext.TRIANGLE_STRIP, indexBuffer.length, glContext.UNSIGNED_SHORT, 0);

        readFromTexture(glContext);
      }

      function initWebGL(){
        glContext = getGLContext('webgl-canvas');
        console.log("glContext "+glContext);
        var float_texture = glContext.getExtension('OES_texture_float');//active l'extension
        initProgram();
        console.log("initProgram");
        //prg = glContext.createProgram();
        initBuffers();
        console.log("initBuffers");
        createBaseTexture();
        console.log("createBaseTexture "+textureA);
      //  initTextureFramebuffer();
      //  console.log("initTextureFramebuffer");
        renderLoop();
      }
    </script>
</head>
<body>
  <h2>Entrer un fichier JSON contenant une matrice</h2>
  <input type="file" id="fileJson" name="files[]" accept=".json"/>
  <h3>Voici les deux matrices entrées</h3>
  <h4>Matrice A</h4>
  <table id="matrixATable">
  </table>
  <h4>Matrice B</h4>
  <table id="matrixBTable">
  </table>
  <br/>
  <h2>Résultat</h2>
  <table id="resultTable">
  </table>
  <p>webgl-canvas</p>
  <canvas id="webgl-canvas" width="128" height="128">
    HTML5 is not supported
  </canvas>
  <canvas id="canvas2" width="128" height="128">
    HTML5 is not supported
  </canvas>
  <script>
  document.getElementById("fileJson").addEventListener("change",changeFileJson,false);
    //Récupération du fichier.
    function changeFileJson(evt){
      var file = evt.target.files[0];
      var fileJson = evt.target;
      var reader = new FileReader();
      reader.onload = function(){
        var text = reader.result;
        var parseText = JSON.parse(text);
        createMatrix(parseText);
      };
      reader.readAsText(fileJson.files[0]);
      //console.log("Fichier lu");
    }
    //Create matrix with the JSON file given
    function createMatrix(textJson){
      if(textJson == undefined || textJson.n == undefined || textJson.A == undefined || textJson.B == undefined){
        alert("Le fichier contenant la matrice comporte une erreur");
      }
      else{
        dimension = textJson.n;
        matrixA = new Matrix(dimension);
        matrixB = new Matrix(dimension);
        //Remplissage des matrices
        var size = Math.pow(dimension,2);
        var rowA = 0, rowB =0, colA = 0, colB=0;
        for(var i=0; i<size; i++){
          matrixA.put(rowA, colA++, textJson.A[i]);
          matrixB.put(rowB, colB++, textJson.B[i]);
          if((i+1)%dimension == 0){
            colA = 0;
            colB=0;
            rowA++;
            rowB++;
          }
        }
        console.log("Matrices construites");
      //  matrixA.display('matrixATable');
        //console.log("matrixB");
        //matrixB.display('matrixBTable');
        //console.log("Matrices affichées");
      }
    }
    //Clear the table
    function clearTable(tableID){
      var table = document.getElementById(tableID);
      var row = table.rows.lenght;
      while(row--){
        table.deleteRow(row);
      }
    }
    //Pour que tout le DOM soit construit avant
    initWebGL();
  </script>
</body>
</html>

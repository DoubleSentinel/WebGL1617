<!DOCTYPE HTML>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Calcul matriciel</title>
    <link rel="stylesheet" href="../css/stylesheet.css">
		<!-- import of webgl utilities -->
    <script src="../sharedJs/commonFunctions.js"></script>
    <script src="../sharedJs/gl-matrix-min.js"></script>
    <script src="../sharedJs/webglTools.js"></script>
		<script src="debug/webgl-debug.js"></script>
		<!-- import application scripts -->
    <script src="./js/matrix.js"></script>

    <!-- vertex shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
  			attribute vec4 aColor;
  			uniform mat4 uMVMatrix;
  			uniform mat4 uPMatrix;
  			varying vec4 vColor;
  			void main(void) {
  				vColor = aColor;
  				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  			}
    </script>
    <!-- fragment shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
				varying vec4 vColor;
				void main(void) {
				  gl_FragColor = vColor;
				}
    </script>
    <!--WebGL logique-->
    <script>
    var vertexBuffer = null;
    var indexBuffer = null;
    var textCoordsBuffer = null;
    var texColorTab = new Array();
    var indices = [];
    var vertices = [];
    var textCoords =[];
    var mvMatrix = mat4.create();
    var pMatrix = mat4.create();
    var textureSize = 1024;
    function initShaderParameters(prg){
      prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
      glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
      prg.textureCoordsAttribute  = glContext.getAttribLocation(prg, "aTextureCoord");
      glContext.enableVertexAttribArray(prg.textureCoordsAttribute);
      prg.pMatrixUniform          = glContext.getUniformLocation(prg, 'uPMatrix');
      prg.mvMatrixUniform         = glContext.getUniformLocation(prg, 'uMVMatrix');
      prg.modeUniform 		    = glContext.getUniformLocation(prg, "uMode");
      prg.uColorTexture 			= glContext.getUniformLocation(prg, "uColorTexture");
    }
    function initBuffers(){
      vertices = [ -1.2, -1.0, 0.0,
              1.2, -1.0, 0.0,
             -1.2,  1.0, 0.0,
              1.2,  1.0, 0.0 ];
      indices = [ 0, 1, 2, 3 ];
      textCoords = [  0.0, 0.0,
              1.0, 0.0,
              0.0, 1.0,
              1.0, 1.0 ];
      vertexBuffer     = getArrayBufferWithArray(vertices);
      indexBuffer      = getIndexBufferWithIndices(indices);
      textCoordsBuffer = getArrayBufferWithArray(textCoords);
    }
    var TEXTURE_RENDERING_MODE = 1;
    var SCREEN_RENDERING_MODE = 0;
    var renderPasses = 0;
    var currentTextureIndx;
    var rttFramebuffer = new Array();
    var rttTexture = new Array();
    function initTextureFramebuffer(index) {
      rttFramebuffer[index] = glContext.createFramebuffer();
      glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[index]);
      rttFramebuffer[index].width = textureSize;
      rttFramebuffer[index].height = textureSize;
      rttTexture[index] = glContext.createTexture();
      glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[index]);
      glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
      glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
      glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, rttFramebuffer[index].width,
      rttFramebuffer[index].height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);
      var renderbuffer = glContext.createRenderbuffer();
      glContext.bindRenderbuffer(glContext.RENDERBUFFER, renderbuffer);
      glContext.renderbufferStorage(glContext.RENDERBUFFER, glContext.DEPTH_COMPONENT16,
      rttFramebuffer[index].width, rttFramebuffer[index].height);
      glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0,
      glContext.TEXTURE_2D, rttTexture[index], 0);
      glContext.framebufferRenderbuffer(glContext.FRAMEBUFFER, glContext.DEPTH_ATTACHMENT,
      glContext.RENDERBUFFER, renderbuffer);
      glContext.bindTexture(glContext.TEXTURE_2D, null);
      glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
      glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
      }
    function glContextCommonBindInfo(){
      glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
      glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
      glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
      glContext.vertexAttribPointer(prg.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);
      glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
      }
    function identityMatrices() {
      mat4.identity(pMatrix);
      glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
      mat4.identity(mvMatrix);
      rotateModelViewMatrixUsingQuaternion(true);
      glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
    }
    function clearBkGd(){
      glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
      glContext.clearColor(0.9, 0.9, 1.0, 1.0);
    }
      function renderATextureInTexture(index){
        glContext.viewport(0, 0, rttFramebuffer[index].width, rttFramebuffer[index].height);
        clearBkGd();
        if (renderPasses<4){
          glContext.bindTexture(glContext.TEXTURE_2D, texColorTab[0]);
          renderPasses++;
        }else{
          glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[index == 0 ? 1 : 0]);
        }
        identityMatrices();
        glContextCommonBindInfo();
        glContext.uniform1i(prg.modeUniform, TEXTURE_RENDERING_MODE);
        glContext.activeTexture(glContext.TEXTURE0);
        glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT, 0);
      }

    function renderOnTheScreenWithoutPerspective(){
      glContext.viewport( 0.0, 0.0, c_width, c_height);
      glContext.enable(glContext.DEPTH_TEST);
      clearBkGd();
      identityMatrices();
      glContextCommonBindInfo();
      glContext.uniform1i(prg.modeUniform, SCREEN_RENDERING_MODE);
      glContext.activeTexture(glContext.TEXTURE0);
      glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[currentTextureIndx]);
      glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT, 0);
    }

    function initWebGL(){
      glContext = getGLContext('webgl-canvas');
      initProgram();
      initBuffers();
      initTextureWithImage( "fig/tree_512x512.png", texColorTab );
      initTextureFramebuffer(0);
      initTextureFramebuffer(1);
      currentTextureIndx = 0;
      renderLoop();
    }
    </script>
</head>
<body>
  <h2>Entrer un fichier JSON contenant une matrice</h2>
  <input type="file" id="fileJson" name="files[]" accept=".json"/>
  <h3>Voici les deux matrices entrées</h3>
  <h4>Matrice A</h4>
  <table id="matrixATable">
  </table>
  <h4>Matrice B</h4>
  <table id="matrixBTable">
  </table>
  <br/>
  <h2>Résultat</h2>
  <table id="resultTable">
  </table>
  <script>
  document.getElementById("fileJson").addEventListener("change",changeFileJson,false);
    //Récupération du fichier.
    function changeFileJson(evt){
      var file = evt.target.files[0];
      var fileJson = evt.target;
      var reader = new FileReader();
      reader.onload = function(){
        var text = reader.result;
        var parseText = JSON.parse(text);
        createMatrix(parseText);
      };
      reader.readAsText(fileJson.files[0]);
      //console.log("Fichier lu");
    }
    //Create matrix with the JSON file given
    function createMatrix(textJson){
      if(textJson == undefined || textJson.n == undefined || textJson.A == undefined || textJson.B == undefined){
        alert("Le fichier contenant la matrice comporte une erreur");
      }
      else{
        dimension = textJson.n;
        matrixA = new Matrix(dimension);
        matrixB = new Matrix(dimension);
        //Remplissage des matrices
        var size = Math.pow(dimension,2);
        var rowA = 0, rowB =0, colA = 0, colB=0;
        for(var i=0; i<size; i++){
          matrixA.put(rowA, colA++, textJson.A[i]);
          matrixB.put(rowB, colB++, textJson.B[i]);
          if((i+1)%dimension == 0){
            colA = 0;
            colB=0;
            rowA++;
            rowB++;
          }
        }
        console.log("Matrices construites");
        matrixA.display("matrixATable");
        matrixB.display("matrixBTable");
        console.log("Matrices affichées");
      }
    }
    //Clear the table
    function clearTable(tableID){
      var table = document.getElementById(tableID);
      var row = table.rows.lenght;
      while(row--){
        table.deleteRow(row);
      }
    }

  </script>
</body>
</html>
